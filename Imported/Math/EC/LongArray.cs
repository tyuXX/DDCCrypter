// Decompiled with JetBrains decompiler
// Type: Org.BouncyCastle.Math.EC.LongArray
// Assembly: BouncyCastle.Crypto, Version=1.8.1.0, Culture=neutral, PublicKeyToken=0e99375e54769942
// MVID: 2C1E8153-B25B-4CDE-9676-EEDAF8A00392
// Assembly location: C:\Users\MÜRVET YÜZDEN ŞEN\Downloads\BouncyCastle.Crypto.dll

using Org.BouncyCastle.Utilities;

namespace Org.BouncyCastle.Math.EC
{
    internal class LongArray
    {
        private const string ZEROES = "0000000000000000000000000000000000000000000000000000000000000000";
        private static readonly ushort[] INTERLEAVE2_TABLE = new ushort[256]
        {
       0,
       1,
       4,
       5,
       16,
       17,
       20,
       21,
       64,
       65,
       68,
       69,
       80,
       81,
       84,
       85,
       256,
       257,
       260,
       261,
       272,
       273,
       276,
       277,
       320,
       321,
       324,
       325,
       336,
       337,
       340,
       341,
       1024,
       1025,
       1028,
       1029,
       1040,
       1041,
       1044,
       1045,
       1088,
       1089,
       1092,
       1093,
       1104,
       1105,
       1108,
       1109,
       1280,
       1281,
       1284,
       1285,
       1296,
       1297,
       1300,
       1301,
       1344,
       1345,
       1348,
       1349,
       1360,
       1361,
       1364,
       1365,
       4096,
       4097,
       4100,
       4101,
       4112,
       4113,
       4116,
       4117,
       4160,
       4161,
       4164,
       4165,
       4176,
       4177,
       4180,
       4181,
       4352,
       4353,
       4356,
       4357,
       4368,
       4369,
       4372,
       4373,
       4416,
       4417,
       4420,
       4421,
       4432,
       4433,
       4436,
       4437,
       5120,
       5121,
       5124,
       5125,
       5136,
       5137,
       5140,
       5141,
       5184,
       5185,
       5188,
       5189,
       5200,
       5201,
       5204,
       5205,
       5376,
       5377,
       5380,
       5381,
       5392,
       5393,
       5396,
       5397,
       5440,
       5441,
       5444,
       5445,
       5456,
       5457,
       5460,
       5461,
       16384,
       16385,
       16388,
       16389,
       16400,
       16401,
       16404,
       16405,
       16448,
       16449,
       16452,
       16453,
       16464,
       16465,
       16468,
       16469,
       16640,
       16641,
       16644,
       16645,
       16656,
       16657,
       16660,
       16661,
       16704,
       16705,
       16708,
       16709,
       16720,
       16721,
       16724,
       16725,
       17408,
       17409,
       17412,
       17413,
       17424,
       17425,
       17428,
       17429,
       17472,
       17473,
       17476,
       17477,
       17488,
       17489,
       17492,
       17493,
       17664,
       17665,
       17668,
       17669,
       17680,
       17681,
       17684,
       17685,
       17728,
       17729,
       17732,
       17733,
       17744,
       17745,
       17748,
       17749,
       20480,
       20481,
       20484,
       20485,
       20496,
       20497,
       20500,
       20501,
       20544,
       20545,
       20548,
       20549,
       20560,
       20561,
       20564,
       20565,
       20736,
       20737,
       20740,
       20741,
       20752,
       20753,
       20756,
       20757,
       20800,
       20801,
       20804,
       20805,
       20816,
       20817,
       20820,
       20821,
       21504,
       21505,
       21508,
       21509,
       21520,
       21521,
       21524,
       21525,
       21568,
       21569,
       21572,
       21573,
       21584,
       21585,
       21588,
       21589,
       21760,
       21761,
       21764,
       21765,
       21776,
       21777,
       21780,
       21781,
       21824,
       21825,
       21828,
       21829,
       21840,
       21841,
       21844,
       21845
        };
        private static readonly int[] INTERLEAVE3_TABLE = new int[128]
        {
      0,
      1,
      8,
      9,
      64,
      65,
      72,
      73,
      512,
      513,
      520,
      521,
      576,
      577,
      584,
      585,
      4096,
      4097,
      4104,
      4105,
      4160,
      4161,
      4168,
      4169,
      4608,
      4609,
      4616,
      4617,
      4672,
      4673,
      4680,
      4681,
      32768,
      32769,
      32776,
      32777,
      32832,
      32833,
      32840,
      32841,
      33280,
      33281,
      33288,
      33289,
      33344,
      33345,
      33352,
      33353,
      36864,
      36865,
      36872,
      36873,
      36928,
      36929,
      36936,
      36937,
      37376,
      37377,
      37384,
      37385,
      37440,
      37441,
      37448,
      37449,
      262144,
      262145,
      262152,
      262153,
      262208,
      262209,
      262216,
      262217,
      262656,
      262657,
      262664,
      262665,
      262720,
      262721,
      262728,
      262729,
      266240,
      266241,
      266248,
      266249,
      266304,
      266305,
      266312,
      266313,
      266752,
      266753,
      266760,
      266761,
      266816,
      266817,
      266824,
      266825,
      294912,
      294913,
      294920,
      294921,
      294976,
      294977,
      294984,
      294985,
      295424,
      295425,
      295432,
      295433,
      295488,
      295489,
      295496,
      295497,
      299008,
      299009,
      299016,
      299017,
      299072,
      299073,
      299080,
      299081,
      299520,
      299521,
      299528,
      299529,
      299584,
      299585,
      299592,
      299593
        };
        private static readonly int[] INTERLEAVE4_TABLE = new int[256]
        {
      0,
      1,
      16,
      17,
      256,
      257,
      272,
      273,
      4096,
      4097,
      4112,
      4113,
      4352,
      4353,
      4368,
      4369,
      65536,
      65537,
      65552,
      65553,
      65792,
      65793,
      65808,
      65809,
      69632,
      69633,
      69648,
      69649,
      69888,
      69889,
      69904,
      69905,
      1048576,
      1048577,
      1048592,
      1048593,
      1048832,
      1048833,
      1048848,
      1048849,
      1052672,
      1052673,
      1052688,
      1052689,
      1052928,
      1052929,
      1052944,
      1052945,
      1114112,
      1114113,
      1114128,
      1114129,
      1114368,
      1114369,
      1114384,
      1114385,
      1118208,
      1118209,
      1118224,
      1118225,
      1118464,
      1118465,
      1118480,
      1118481,
      16777216,
      16777217,
      16777232,
      16777233,
      16777472,
      16777473,
      16777488,
      16777489,
      16781312,
      16781313,
      16781328,
      16781329,
      16781568,
      16781569,
      16781584,
      16781585,
      16842752,
      16842753,
      16842768,
      16842769,
      16843008,
      16843009,
      16843024,
      16843025,
      16846848,
      16846849,
      16846864,
      16846865,
      16847104,
      16847105,
      16847120,
      16847121,
      17825792,
      17825793,
      17825808,
      17825809,
      17826048,
      17826049,
      17826064,
      17826065,
      17829888,
      17829889,
      17829904,
      17829905,
      17830144,
      17830145,
      17830160,
      17830161,
      17891328,
      17891329,
      17891344,
      17891345,
      17891584,
      17891585,
      17891600,
      17891601,
      17895424,
      17895425,
      17895440,
      17895441,
      17895680,
      17895681,
      17895696,
      17895697,
      268435456,
      268435457,
      268435472,
      268435473,
      268435712,
      268435713,
      268435728,
      268435729,
      268439552,
      268439553,
      268439568,
      268439569,
      268439808,
      268439809,
      268439824,
      268439825,
      268500992,
      268500993,
      268501008,
      268501009,
      268501248,
      268501249,
      268501264,
      268501265,
      268505088,
      268505089,
      268505104,
      268505105,
      268505344,
      268505345,
      268505360,
      268505361,
      269484032,
      269484033,
      269484048,
      269484049,
      269484288,
      269484289,
      269484304,
      269484305,
      269488128,
      269488129,
      269488144,
      269488145,
      269488384,
      269488385,
      269488400,
      269488401,
      269549568,
      269549569,
      269549584,
      269549585,
      269549824,
      269549825,
      269549840,
      269549841,
      269553664,
      269553665,
      269553680,
      269553681,
      269553920,
      269553921,
      269553936,
      269553937,
      285212672,
      285212673,
      285212688,
      285212689,
      285212928,
      285212929,
      285212944,
      285212945,
      285216768,
      285216769,
      285216784,
      285216785,
      285217024,
      285217025,
      285217040,
      285217041,
      285278208,
      285278209,
      285278224,
      285278225,
      285278464,
      285278465,
      285278480,
      285278481,
      285282304,
      285282305,
      285282320,
      285282321,
      285282560,
      285282561,
      285282576,
      285282577,
      286261248,
      286261249,
      286261264,
      286261265,
      286261504,
      286261505,
      286261520,
      286261521,
      286265344,
      286265345,
      286265360,
      286265361,
      286265600,
      286265601,
      286265616,
      286265617,
      286326784,
      286326785,
      286326800,
      286326801,
      286327040,
      286327041,
      286327056,
      286327057,
      286330880,
      286330881,
      286330896,
      286330897,
      286331136,
      286331137,
      286331152,
      286331153
        };
        private static readonly int[] INTERLEAVE5_TABLE = new int[128]
        {
      0,
      1,
      32,
      33,
      1024,
      1025,
      1056,
      1057,
      32768,
      32769,
      32800,
      32801,
      33792,
      33793,
      33824,
      33825,
      1048576,
      1048577,
      1048608,
      1048609,
      1049600,
      1049601,
      1049632,
      1049633,
      1081344,
      1081345,
      1081376,
      1081377,
      1082368,
      1082369,
      1082400,
      1082401,
      33554432,
      33554433,
      33554464,
      33554465,
      33555456,
      33555457,
      33555488,
      33555489,
      33587200,
      33587201,
      33587232,
      33587233,
      33588224,
      33588225,
      33588256,
      33588257,
      34603008,
      34603009,
      34603040,
      34603041,
      34604032,
      34604033,
      34604064,
      34604065,
      34635776,
      34635777,
      34635808,
      34635809,
      34636800,
      34636801,
      34636832,
      34636833,
      1073741824,
      1073741825,
      1073741856,
      1073741857,
      1073742848,
      1073742849,
      1073742880,
      1073742881,
      1073774592,
      1073774593,
      1073774624,
      1073774625,
      1073775616,
      1073775617,
      1073775648,
      1073775649,
      1074790400,
      1074790401,
      1074790432,
      1074790433,
      1074791424,
      1074791425,
      1074791456,
      1074791457,
      1074823168,
      1074823169,
      1074823200,
      1074823201,
      1074824192,
      1074824193,
      1074824224,
      1074824225,
      1107296256,
      1107296257,
      1107296288,
      1107296289,
      1107297280,
      1107297281,
      1107297312,
      1107297313,
      1107329024,
      1107329025,
      1107329056,
      1107329057,
      1107330048,
      1107330049,
      1107330080,
      1107330081,
      1108344832,
      1108344833,
      1108344864,
      1108344865,
      1108345856,
      1108345857,
      1108345888,
      1108345889,
      1108377600,
      1108377601,
      1108377632,
      1108377633,
      1108378624,
      1108378625,
      1108378656,
      1108378657
        };
        private static readonly long[] INTERLEAVE7_TABLE = new long[512]
        {
      0L,
      1L,
      128L,
      129L,
      16384L,
      16385L,
      16512L,
      16513L,
      2097152L,
      2097153L,
      2097280L,
      2097281L,
      2113536L,
      2113537L,
      2113664L,
      2113665L,
      268435456L,
      268435457L,
      268435584L,
      268435585L,
      268451840L,
      268451841L,
      268451968L,
      268451969L,
      270532608L,
      270532609L,
      270532736L,
      270532737L,
      270548992L,
      270548993L,
      270549120L,
      270549121L,
      34359738368L,
      34359738369L,
      34359738496L,
      34359738497L,
      34359754752L,
      34359754753L,
      34359754880L,
      34359754881L,
      34361835520L,
      34361835521L,
      34361835648L,
      34361835649L,
      34361851904L,
      34361851905L,
      34361852032L,
      34361852033L,
      34628173824L,
      34628173825L,
      34628173952L,
      34628173953L,
      34628190208L,
      34628190209L,
      34628190336L,
      34628190337L,
      34630270976L,
      34630270977L,
      34630271104L,
      34630271105L,
      34630287360L,
      34630287361L,
      34630287488L,
      34630287489L,
      4398046511104L,
      4398046511105L,
      4398046511232L,
      4398046511233L,
      4398046527488L,
      4398046527489L,
      4398046527616L,
      4398046527617L,
      4398048608256L,
      4398048608257L,
      4398048608384L,
      4398048608385L,
      4398048624640L,
      4398048624641L,
      4398048624768L,
      4398048624769L,
      4398314946560L,
      4398314946561L,
      4398314946688L,
      4398314946689L,
      4398314962944L,
      4398314962945L,
      4398314963072L,
      4398314963073L,
      4398317043712L,
      4398317043713L,
      4398317043840L,
      4398317043841L,
      4398317060096L,
      4398317060097L,
      4398317060224L,
      4398317060225L,
      4432406249472L,
      4432406249473L,
      4432406249600L,
      4432406249601L,
      4432406265856L,
      4432406265857L,
      4432406265984L,
      4432406265985L,
      4432408346624L,
      4432408346625L,
      4432408346752L,
      4432408346753L,
      4432408363008L,
      4432408363009L,
      4432408363136L,
      4432408363137L,
      4432674684928L,
      4432674684929L,
      4432674685056L,
      4432674685057L,
      4432674701312L,
      4432674701313L,
      4432674701440L,
      4432674701441L,
      4432676782080L,
      4432676782081L,
      4432676782208L,
      4432676782209L,
      4432676798464L,
      4432676798465L,
      4432676798592L,
      4432676798593L,
      562949953421312L,
      562949953421313L,
      562949953421440L,
      562949953421441L,
      562949953437696L,
      562949953437697L,
      562949953437824L,
      562949953437825L,
      562949955518464L,
      562949955518465L,
      562949955518592L,
      562949955518593L,
      562949955534848L,
      562949955534849L,
      562949955534976L,
      562949955534977L,
      562950221856768L,
      562950221856769L,
      562950221856896L,
      562950221856897L,
      562950221873152L,
      562950221873153L,
      562950221873280L,
      562950221873281L,
      562950223953920L,
      562950223953921L,
      562950223954048L,
      562950223954049L,
      562950223970304L,
      562950223970305L,
      562950223970432L,
      562950223970433L,
      562984313159680L,
      562984313159681L,
      562984313159808L,
      562984313159809L,
      562984313176064L,
      562984313176065L,
      562984313176192L,
      562984313176193L,
      562984315256832L,
      562984315256833L,
      562984315256960L,
      562984315256961L,
      562984315273216L,
      562984315273217L,
      562984315273344L,
      562984315273345L,
      562984581595136L,
      562984581595137L,
      562984581595264L,
      562984581595265L,
      562984581611520L,
      562984581611521L,
      562984581611648L,
      562984581611649L,
      562984583692288L,
      562984583692289L,
      562984583692416L,
      562984583692417L,
      562984583708672L,
      562984583708673L,
      562984583708800L,
      562984583708801L,
      567347999932416L,
      567347999932417L,
      567347999932544L,
      567347999932545L,
      567347999948800L,
      567347999948801L,
      567347999948928L,
      567347999948929L,
      567348002029568L,
      567348002029569L,
      567348002029696L,
      567348002029697L,
      567348002045952L,
      567348002045953L,
      567348002046080L,
      567348002046081L,
      567348268367872L,
      567348268367873L,
      567348268368000L,
      567348268368001L,
      567348268384256L,
      567348268384257L,
      567348268384384L,
      567348268384385L,
      567348270465024L,
      567348270465025L,
      567348270465152L,
      567348270465153L,
      567348270481408L,
      567348270481409L,
      567348270481536L,
      567348270481537L,
      567382359670784L,
      567382359670785L,
      567382359670912L,
      567382359670913L,
      567382359687168L,
      567382359687169L,
      567382359687296L,
      567382359687297L,
      567382361767936L,
      567382361767937L,
      567382361768064L,
      567382361768065L,
      567382361784320L,
      567382361784321L,
      567382361784448L,
      567382361784449L,
      567382628106240L,
      567382628106241L,
      567382628106368L,
      567382628106369L,
      567382628122624L,
      567382628122625L,
      567382628122752L,
      567382628122753L,
      567382630203392L,
      567382630203393L,
      567382630203520L,
      567382630203521L,
      567382630219776L,
      567382630219777L,
      567382630219904L,
      567382630219905L,
      72057594037927936L,
      72057594037927937L,
      72057594037928064L,
      72057594037928065L,
      72057594037944320L,
      72057594037944321L,
      72057594037944448L,
      72057594037944449L,
      72057594040025088L,
      72057594040025089L,
      72057594040025216L,
      72057594040025217L,
      72057594040041472L,
      72057594040041473L,
      72057594040041600L,
      72057594040041601L,
      72057594306363392L,
      72057594306363393L,
      72057594306363520L,
      72057594306363521L,
      72057594306379776L,
      72057594306379777L,
      72057594306379904L,
      72057594306379905L,
      72057594308460544L,
      72057594308460545L,
      72057594308460672L,
      72057594308460673L,
      72057594308476928L,
      72057594308476929L,
      72057594308477056L,
      72057594308477057L,
      72057628397666304L,
      72057628397666305L,
      72057628397666432L,
      72057628397666433L,
      72057628397682688L,
      72057628397682689L,
      72057628397682816L,
      72057628397682817L,
      72057628399763456L,
      72057628399763457L,
      72057628399763584L,
      72057628399763585L,
      72057628399779840L,
      72057628399779841L,
      72057628399779968L,
      72057628399779969L,
      72057628666101760L,
      72057628666101761L,
      72057628666101888L,
      72057628666101889L,
      72057628666118144L,
      72057628666118145L,
      72057628666118272L,
      72057628666118273L,
      72057628668198912L,
      72057628668198913L,
      72057628668199040L,
      72057628668199041L,
      72057628668215296L,
      72057628668215297L,
      72057628668215424L,
      72057628668215425L,
      72061992084439040L,
      72061992084439041L,
      72061992084439168L,
      72061992084439169L,
      72061992084455424L,
      72061992084455425L,
      72061992084455552L,
      72061992084455553L,
      72061992086536192L,
      72061992086536193L,
      72061992086536320L,
      72061992086536321L,
      72061992086552576L,
      72061992086552577L,
      72061992086552704L,
      72061992086552705L,
      72061992352874496L,
      72061992352874497L,
      72061992352874624L,
      72061992352874625L,
      72061992352890880L,
      72061992352890881L,
      72061992352891008L,
      72061992352891009L,
      72061992354971648L,
      72061992354971649L,
      72061992354971776L,
      72061992354971777L,
      72061992354988032L,
      72061992354988033L,
      72061992354988160L,
      72061992354988161L,
      72062026444177408L,
      72062026444177409L,
      72062026444177536L,
      72062026444177537L,
      72062026444193792L,
      72062026444193793L,
      72062026444193920L,
      72062026444193921L,
      72062026446274560L,
      72062026446274561L,
      72062026446274688L,
      72062026446274689L,
      72062026446290944L,
      72062026446290945L,
      72062026446291072L,
      72062026446291073L,
      72062026712612864L,
      72062026712612865L,
      72062026712612992L,
      72062026712612993L,
      72062026712629248L,
      72062026712629249L,
      72062026712629376L,
      72062026712629377L,
      72062026714710016L,
      72062026714710017L,
      72062026714710144L,
      72062026714710145L,
      72062026714726400L,
      72062026714726401L,
      72062026714726528L,
      72062026714726529L,
      72620543991349248L,
      72620543991349249L,
      72620543991349376L,
      72620543991349377L,
      72620543991365632L,
      72620543991365633L,
      72620543991365760L,
      72620543991365761L,
      72620543993446400L,
      72620543993446401L,
      72620543993446528L,
      72620543993446529L,
      72620543993462784L,
      72620543993462785L,
      72620543993462912L,
      72620543993462913L,
      72620544259784704L,
      72620544259784705L,
      72620544259784832L,
      72620544259784833L,
      72620544259801088L,
      72620544259801089L,
      72620544259801216L,
      72620544259801217L,
      72620544261881856L,
      72620544261881857L,
      72620544261881984L,
      72620544261881985L,
      72620544261898240L,
      72620544261898241L,
      72620544261898368L,
      72620544261898369L,
      72620578351087616L,
      72620578351087617L,
      72620578351087744L,
      72620578351087745L,
      72620578351104000L,
      72620578351104001L,
      72620578351104128L,
      72620578351104129L,
      72620578353184768L,
      72620578353184769L,
      72620578353184896L,
      72620578353184897L,
      72620578353201152L,
      72620578353201153L,
      72620578353201280L,
      72620578353201281L,
      72620578619523072L,
      72620578619523073L,
      72620578619523200L,
      72620578619523201L,
      72620578619539456L,
      72620578619539457L,
      72620578619539584L,
      72620578619539585L,
      72620578621620224L,
      72620578621620225L,
      72620578621620352L,
      72620578621620353L,
      72620578621636608L,
      72620578621636609L,
      72620578621636736L,
      72620578621636737L,
      72624942037860352L,
      72624942037860353L,
      72624942037860480L,
      72624942037860481L,
      72624942037876736L,
      72624942037876737L,
      72624942037876864L,
      72624942037876865L,
      72624942039957504L,
      72624942039957505L,
      72624942039957632L,
      72624942039957633L,
      72624942039973888L,
      72624942039973889L,
      72624942039974016L,
      72624942039974017L,
      72624942306295808L,
      72624942306295809L,
      72624942306295936L,
      72624942306295937L,
      72624942306312192L,
      72624942306312193L,
      72624942306312320L,
      72624942306312321L,
      72624942308392960L,
      72624942308392961L,
      72624942308393088L,
      72624942308393089L,
      72624942308409344L,
      72624942308409345L,
      72624942308409472L,
      72624942308409473L,
      72624976397598720L,
      72624976397598721L,
      72624976397598848L,
      72624976397598849L,
      72624976397615104L,
      72624976397615105L,
      72624976397615232L,
      72624976397615233L,
      72624976399695872L,
      72624976399695873L,
      72624976399696000L,
      72624976399696001L,
      72624976399712256L,
      72624976399712257L,
      72624976399712384L,
      72624976399712385L,
      72624976666034176L,
      72624976666034177L,
      72624976666034304L,
      72624976666034305L,
      72624976666050560L,
      72624976666050561L,
      72624976666050688L,
      72624976666050689L,
      72624976668131328L,
      72624976668131329L,
      72624976668131456L,
      72624976668131457L,
      72624976668147712L,
      72624976668147713L,
      72624976668147840L,
      72624976668147841L
        };
        internal static readonly byte[] BitLengths = new byte[256]
        {
       0,
       1,
       2,
       2,
       3,
       3,
       3,
       3,
       4,
       4,
       4,
       4,
       4,
       4,
       4,
       4,
       5,
       5,
       5,
       5,
       5,
       5,
       5,
       5,
       5,
       5,
       5,
       5,
       5,
       5,
       5,
       5,
       6,
       6,
       6,
       6,
       6,
       6,
       6,
       6,
       6,
       6,
       6,
       6,
       6,
       6,
       6,
       6,
       6,
       6,
       6,
       6,
       6,
       6,
       6,
       6,
       6,
       6,
       6,
       6,
       6,
       6,
       6,
       6,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       7,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8,
       8
        };
        private long[] m_ints;

        public LongArray( int intLen ) => this.m_ints = new long[intLen];

        public LongArray( long[] ints ) => this.m_ints = ints;

        public LongArray( long[] ints, int off, int len )
        {
            if (off == 0 && len == ints.Length)
            {
                this.m_ints = ints;
            }
            else
            {
                this.m_ints = new long[len];
                Array.Copy( ints, off, m_ints, 0, len );
            }
        }

        public LongArray( BigInteger bigInt )
        {
            if (bigInt == null || bigInt.SignValue < 0)
                throw new ArgumentException( "invalid F2m field value", nameof( bigInt ) );
            if (bigInt.SignValue == 0)
            {
                this.m_ints = new long[1];
            }
            else
            {
                byte[] byteArray = bigInt.ToByteArray();
                int length1 = byteArray.Length;
                int num1 = 0;
                if (byteArray[0] == 0)
                {
                    --length1;
                    num1 = 1;
                }
                int length2 = (length1 + 7) / 8;
                this.m_ints = new long[length2];
                int index1 = length2 - 1;
                int num2 = (length1 % 8) + num1;
                long num3 = 0;
                int index2 = num1;
                if (num1 < num2)
                {
                    for (; index2 < num2; ++index2)
                        num3 = (num3 << 8) | byteArray[index2];
                    this.m_ints[index1--] = num3;
                }
                for (; index1 >= 0; --index1)
                {
                    long num4 = 0;
                    for (int index3 = 0; index3 < 8; ++index3)
                        num4 = (num4 << 8) | byteArray[index2++];
                    this.m_ints[index1] = num4;
                }
            }
        }

        public bool IsOne()
        {
            long[] ints = this.m_ints;
            if (ints[0] != 1L)
                return false;
            for (int index = 1; index < ints.Length; ++index)
            {
                if (ints[index] != 0L)
                    return false;
            }
            return true;
        }

        public bool IsZero()
        {
            foreach (long num in this.m_ints)
            {
                if (num != 0L)
                    return false;
            }
            return true;
        }

        public int GetUsedLength() => this.GetUsedLengthFrom( this.m_ints.Length );

        public int GetUsedLengthFrom( int from )
        {
            long[] ints = this.m_ints;
            from = System.Math.Min( from, ints.Length );
            if (from < 1)
                return 0;
            if (ints[0] != 0L)
            {
                do
                    ;
                while (ints[--from] == 0L);
                return from + 1;
            }
            while (ints[--from] == 0L)
            {
                if (from <= 0)
                    return 0;
            }
            return from + 1;
        }

        public int Degree()
        {
            int length = this.m_ints.Length;
            while (length != 0)
            {
                long w = this.m_ints[--length];
                if (w != 0L)
                    return (length << 6) + BitLength( w );
            }
            return 0;
        }

        private int DegreeFrom( int limit )
        {
            int num = limit + 62 >>> 6;
            while (num != 0)
            {
                long w = this.m_ints[--num];
                if (w != 0L)
                    return (num << 6) + BitLength( w );
            }
            return 0;
        }

        private static int BitLength( long w )
        {
            int index1 = (int)(w >>> 32);
            int num1;
            if (index1 == 0)
            {
                index1 = (int)w;
                num1 = 0;
            }
            else
                num1 = 32;
            int index2 = index1 >>> 16;
            int num2;
            if (index2 == 0)
            {
                int index3 = index1 >>> 8;
                num2 = index3 == 0 ? BitLengths[index1] : 8 + BitLengths[index3];
            }
            else
            {
                int index4 = index2 >>> 8;
                num2 = index4 == 0 ? 16 + BitLengths[index2] : 24 + BitLengths[index4];
            }
            return num1 + num2;
        }

        private long[] ResizedInts( int newLen )
        {
            long[] destinationArray = new long[newLen];
            Array.Copy( m_ints, 0, destinationArray, 0, System.Math.Min( this.m_ints.Length, newLen ) );
            return destinationArray;
        }

        public BigInteger ToBigInteger()
        {
            int usedLength = this.GetUsedLength();
            if (usedLength == 0)
                return BigInteger.Zero;
            long num1 = this.m_ints[usedLength - 1];
            byte[] numArray = new byte[8];
            int num2 = 0;
            bool flag = false;
            for (int index = 7; index >= 0; --index)
            {
                byte num3 = (byte)(num1 >>> 8 * index);
                if (flag || num3 != 0)
                {
                    flag = true;
                    numArray[num2++] = num3;
                }
            }
            byte[] bytes = new byte[(8 * (usedLength - 1)) + num2];
            for (int index = 0; index < num2; ++index)
                bytes[index] = numArray[index];
            for (int index1 = usedLength - 2; index1 >= 0; --index1)
            {
                long num4 = this.m_ints[index1];
                for (int index2 = 7; index2 >= 0; --index2)
                    bytes[num2++] = (byte)(num4 >>> 8 * index2);
            }
            return new BigInteger( 1, bytes );
        }

        private static long ShiftUp( long[] x, int xOff, int count, int shift )
        {
            int num1 = 64 - shift;
            long num2 = 0;
            for (int index = 0; index < count; ++index)
            {
                long num3 = x[xOff + index];
                x[xOff + index] = (num3 << shift) | num2;
                num2 = num3 >>> num1;
            }
            return num2;
        }

        private static long ShiftUp( long[] x, int xOff, long[] z, int zOff, int count, int shift )
        {
            int num1 = 64 - shift;
            long num2 = 0;
            for (int index = 0; index < count; ++index)
            {
                long num3 = x[xOff + index];
                z[zOff + index] = (num3 << shift) | num2;
                num2 = num3 >>> num1;
            }
            return num2;
        }

        public LongArray AddOne()
        {
            if (this.m_ints.Length == 0)
                return new LongArray( new long[1] { 1L } );
            long[] ints = this.ResizedInts( System.Math.Max( 1, this.GetUsedLength() ) );
            long[] numArray;
            (numArray = ints)[0] = numArray[0] ^ 1L;
            return new LongArray( ints );
        }

        private void AddShiftedByBitsSafe( LongArray other, int otherDegree, int bits )
        {
            int count = otherDegree + 63 >>> 6;
            int xOff = bits >>> 6;
            int shift = bits & 63;
            if (shift == 0)
            {
                Add( this.m_ints, xOff, other.m_ints, 0, count );
            }
            else
            {
                long num = AddShiftedUp( this.m_ints, xOff, other.m_ints, 0, count, shift );
                if (num == 0L)
                    return;
                this.m_ints[count + xOff] ^= num;
            }
        }

        private static long AddShiftedUp(
          long[] x,
          int xOff,
          long[] y,
          int yOff,
          int count,
          int shift )
        {
            int num1 = 64 - shift;
            long num2 = 0;
            for (int index = 0; index < count; ++index)
            {
                long num3 = y[yOff + index];
                x[xOff + index] ^= (num3 << shift) | num2;
                num2 = num3 >>> num1;
            }
            return num2;
        }

        private static long AddShiftedDown(
          long[] x,
          int xOff,
          long[] y,
          int yOff,
          int count,
          int shift )
        {
            int num1 = 64 - shift;
            long num2 = 0;
            int num3 = count;
            while (--num3 >= 0)
            {
                long num4 = y[yOff + num3];
                x[xOff + num3] ^= num4 >>> shift | num2;
                num2 = num4 << num1;
            }
            return num2;
        }

        public void AddShiftedByWords( LongArray other, int words )
        {
            int usedLength = other.GetUsedLength();
            if (usedLength == 0)
                return;
            int newLen = usedLength + words;
            if (newLen > this.m_ints.Length)
                this.m_ints = this.ResizedInts( newLen );
            Add( this.m_ints, words, other.m_ints, 0, usedLength );
        }

        private static void Add( long[] x, int xOff, long[] y, int yOff, int count )
        {
            for (int index = 0; index < count; ++index)
                x[xOff + index] ^= y[yOff + index];
        }

        private static void Add(
          long[] x,
          int xOff,
          long[] y,
          int yOff,
          long[] z,
          int zOff,
          int count )
        {
            for (int index = 0; index < count; ++index)
                z[zOff + index] = x[xOff + index] ^ y[yOff + index];
        }

        private static void AddBoth(
          long[] x,
          int xOff,
          long[] y1,
          int y1Off,
          long[] y2,
          int y2Off,
          int count )
        {
            for (int index = 0; index < count; ++index)
                x[xOff + index] ^= y1[y1Off + index] ^ y2[y2Off + index];
        }

        private static void Distribute( long[] x, int src, int dst1, int dst2, int count )
        {
            for (int index = 0; index < count; ++index)
            {
                long num = x[src + index];
                x[dst1 + index] ^= num;
                x[dst2 + index] ^= num;
            }
        }

        public int Length => this.m_ints.Length;

        private static void FlipWord( long[] buf, int off, int bit, long word )
        {
            int index1 = off + (bit >>> 6);
            int num1 = bit & 63;
            if (num1 == 0)
            {
                buf[index1] ^= word;
            }
            else
            {
                buf[index1] ^= word << num1;
                word >>>= 64 - num1;
                if (word == 0L)
                    return;
                long[] numArray1;
                long[] numArray2 = numArray1 = buf;
                int index2;
                int num2 = index2 = index1 + 1;
                int index3 = index2;
                long num3 = numArray2[(int)(IntPtr)index3] ^ word;
                numArray1[index2] = num3;
            }
        }

        public bool TestBitZero() => this.m_ints.Length > 0 && (this.m_ints[0] & 1L) != 0L;

        private static bool TestBit( long[] buf, int off, int n )
        {
            int num1 = n >>> 6;
            long num2 = 1L << n;
            return (buf[off + num1] & num2) != 0L;
        }

        private static void FlipBit( long[] buf, int off, int n )
        {
            int num1 = n >>> 6;
            long num2 = 1L << n;
            buf[off + num1] ^= num2;
        }

        private static void MultiplyWord( long a, long[] b, int bLen, long[] c, int cOff )
        {
            if ((a & 1L) != 0L)
                Add( c, cOff, b, 0, bLen );
            int shift = 1;
            while ((a >>>= 1) != 0L)
            {
                if ((a & 1L) != 0L)
                {
                    long num = AddShiftedUp( c, cOff, b, 0, bLen, shift );
                    if (num != 0L)
                        c[cOff + bLen] ^= num;
                }
                ++shift;
            }
        }

        public LongArray ModMultiplyLD( LongArray other, int m, int[] ks )
        {
            int num1 = this.Degree();
            if (num1 == 0)
                return this;
            int num2 = other.Degree();
            if (num2 == 0)
                return other;
            LongArray longArray1 = this;
            LongArray longArray2 = other;
            if (num1 > num2)
            {
                longArray1 = other;
                longArray2 = this;
                int num3 = num1;
                num1 = num2;
                num2 = num3;
            }
            int num4 = num1 + 63 >>> 6;
            int num5 = num2 + 63 >>> 6;
            int length = num1 + num2 + 62 >>> 6;
            if (num4 == 1)
            {
                long a = longArray1.m_ints[0];
                if (a == 1L)
                    return longArray2;
                long[] numArray = new long[length];
                MultiplyWord( a, longArray2.m_ints, num5, numArray, 0 );
                return ReduceResult( numArray, 0, length, m, ks );
            }
            int num6 = num2 + 7 + 63 >>> 6;
            int[] numArray1 = new int[16];
            long[] numArray2 = new long[num6 << 4];
            int num7 = num6;
            numArray1[1] = num7;
            Array.Copy( longArray2.m_ints, 0, numArray2, num7, num5 );
            for (int index = 2; index < 16; ++index)
            {
                numArray1[index] = num7 += num6;
                if ((index & 1) == 0)
                    ShiftUp( numArray2, num7 >>> 1, numArray2, num7, num6, 1 );
                else
                    Add( numArray2, num6, numArray2, num7 - num6, numArray2, num7, num6 );
            }
            long[] numArray3 = new long[numArray2.Length];
            ShiftUp( numArray2, 0, numArray3, 0, numArray2.Length, 4 );
            long[] ints = longArray1.m_ints;
            long[] numArray4 = new long[length];
            int num8 = 15;
            for (int index1 = 56; index1 >= 0; index1 -= 8)
            {
                for (int index2 = 1; index2 < num4; index2 += 2)
                {
                    int num9 = (int)(ints[index2] >>> index1);
                    int index3 = num9 & num8;
                    int index4 = num9 >>> 4 & num8;
                    AddBoth( numArray4, index2 - 1, numArray2, numArray1[index3], numArray3, numArray1[index4], num6 );
                }
                ShiftUp( numArray4, 0, length, 8 );
            }
            for (int index5 = 56; index5 >= 0; index5 -= 8)
            {
                for (int xOff = 0; xOff < num4; xOff += 2)
                {
                    int num10 = (int)(ints[xOff] >>> index5);
                    int index6 = num10 & num8;
                    int index7 = num10 >>> 4 & num8;
                    AddBoth( numArray4, xOff, numArray2, numArray1[index6], numArray3, numArray1[index7], num6 );
                }
                if (index5 > 0)
                    ShiftUp( numArray4, 0, length, 8 );
            }
            return ReduceResult( numArray4, 0, length, m, ks );
        }

        public LongArray ModMultiply( LongArray other, int m, int[] ks )
        {
            int num1 = this.Degree();
            if (num1 == 0)
                return this;
            int num2 = other.Degree();
            if (num2 == 0)
                return other;
            LongArray longArray1 = this;
            LongArray longArray2 = other;
            if (num1 > num2)
            {
                longArray1 = other;
                longArray2 = this;
                int num3 = num1;
                num1 = num2;
                num2 = num3;
            }
            int num4 = num1 + 63 >>> 6;
            int num5 = num2 + 63 >>> 6;
            int length1 = num1 + num2 + 62 >>> 6;
            if (num4 == 1)
            {
                long a = longArray1.m_ints[0];
                if (a == 1L)
                    return longArray2;
                long[] numArray = new long[length1];
                MultiplyWord( a, longArray2.m_ints, num5, numArray, 0 );
                return ReduceResult( numArray, 0, length1, m, ks );
            }
            int num6 = num2 + 7 + 63 >>> 6;
            int[] numArray1 = new int[16];
            long[] numArray2 = new long[num6 << 4];
            int num7 = num6;
            numArray1[1] = num7;
            Array.Copy( longArray2.m_ints, 0, numArray2, num7, num5 );
            for (int index = 2; index < 16; ++index)
            {
                numArray1[index] = num7 += num6;
                if ((index & 1) == 0)
                    ShiftUp( numArray2, num7 >>> 1, numArray2, num7, num6, 1 );
                else
                    Add( numArray2, num6, numArray2, num7 - num6, numArray2, num7, num6 );
            }
            long[] numArray3 = new long[numArray2.Length];
            ShiftUp( numArray2, 0, numArray3, 0, numArray2.Length, 4 );
            long[] ints = longArray1.m_ints;
            long[] numArray4 = new long[length1 << 3];
            int num8 = 15;
            for (int index1 = 0; index1 < num4; ++index1)
            {
                long num9 = ints[index1];
                int xOff = index1;
                while (true)
                {
                    int index2 = (int)num9 & num8;
                    long num10 = num9 >>> 4;
                    int index3 = (int)num10 & num8;
                    AddBoth( numArray4, xOff, numArray2, numArray1[index2], numArray3, numArray1[index3], num6 );
                    num9 = num10 >>> 4;
                    if (num9 != 0L)
                        xOff += length1;
                    else
                        break;
                }
            }
            int length2 = numArray4.Length;
            while ((length2 -= length1) != 0)
                AddShiftedUp( numArray4, length2 - length1, numArray4, length2, length1, 8 );
            return ReduceResult( numArray4, 0, length1, m, ks );
        }

        public LongArray ModMultiplyAlt( LongArray other, int m, int[] ks )
        {
            int num1 = this.Degree();
            if (num1 == 0)
                return this;
            int num2 = other.Degree();
            if (num2 == 0)
                return other;
            LongArray longArray1 = this;
            LongArray longArray2 = other;
            if (num1 > num2)
            {
                longArray1 = other;
                longArray2 = this;
                int num3 = num1;
                num1 = num2;
                num2 = num3;
            }
            int num4 = num1 + 63 >>> 6;
            int num5 = num2 + 63 >>> 6;
            int length1 = num1 + num2 + 62 >>> 6;
            if (num4 == 1)
            {
                long a = longArray1.m_ints[0];
                if (a == 1L)
                    return longArray2;
                long[] numArray = new long[length1];
                MultiplyWord( a, longArray2.m_ints, num5, numArray, 0 );
                return ReduceResult( numArray, 0, length1, m, ks );
            }
            int width = 4;
            int shift1 = 16;
            int num6 = 64;
            int shift2 = 8;
            int num7 = num6 < 64 ? shift1 : shift1 - 1;
            int count1 = num2 + num7 + 63 >>> 6;
            int count2 = count1 * shift2;
            int num8 = width * shift2;
            int[] numArray1 = new int[1 << width];
            int num9 = num4;
            numArray1[0] = num9;
            int num10 = num9 + count2;
            numArray1[1] = num10;
            for (int index = 2; index < numArray1.Length; ++index)
            {
                num10 += length1;
                numArray1[index] = num10;
            }
            long[] numArray2 = new long[num10 + length1 + 1];
            Interleave( longArray1.m_ints, 0, numArray2, 0, num4, width );
            int destinationIndex = num4;
            Array.Copy( longArray2.m_ints, 0, numArray2, destinationIndex, num5 );
            for (int shift3 = 1; shift3 < shift2; ++shift3)
                ShiftUp( numArray2, num4, numArray2, destinationIndex += count1, count1, shift3 );
            int num11 = (1 << width) - 1;
            int num12 = 0;
            while (true)
            {
                int index1 = 0;
                do
                {
                    long num13 = numArray2[index1] >>> num12;
                    int num14 = 0;
                    int yOff = num4;
                    while (true)
                    {
                        int index2 = (int)num13 & num11;
                        if (index2 != 0)
                            Add( numArray2, index1 + numArray1[index2], numArray2, yOff, count1 );
                        if (++num14 != shift2)
                        {
                            yOff += count1;
                            num13 >>>= width;
                        }
                        else
                            break;
                    }
                }
                while (++index1 < num4);
                if ((num12 += num8) >= num6)
                {
                    if (num12 < 64)
                    {
                        num12 = 64 - width;
                        num11 &= num11 << (num6 - num12);
                    }
                    else
                        break;
                }
                ShiftUp( numArray2, num4, count2, shift2 );
            }
            int length2 = numArray1.Length;
            while (--length2 > 1)
            {
                if ((length2 & 1L) == 0L)
                    AddShiftedUp( numArray2, numArray1[(int)(IntPtr)(uint)(length2 >>> 1)], numArray2, numArray1[length2], length1, shift1 );
                else
                    Distribute( numArray2, numArray1[length2], numArray1[length2 - 1], numArray1[1], length1 );
            }
            return ReduceResult( numArray2, numArray1[1], length1, m, ks );
        }

        public LongArray ModReduce( int m, int[] ks )
        {
            long[] numArray = Arrays.Clone( this.m_ints );
            int len = ReduceInPlace( numArray, 0, numArray.Length, m, ks );
            return new LongArray( numArray, 0, len );
        }

        public LongArray Multiply( LongArray other, int m, int[] ks )
        {
            int num1 = this.Degree();
            if (num1 == 0)
                return this;
            int num2 = other.Degree();
            if (num2 == 0)
                return other;
            LongArray longArray1 = this;
            LongArray longArray2 = other;
            if (num1 > num2)
            {
                longArray1 = other;
                longArray2 = this;
                int num3 = num1;
                num1 = num2;
                num2 = num3;
            }
            int num4 = num1 + 63 >>> 6;
            int num5 = num2 + 63 >>> 6;
            int length1 = num1 + num2 + 62 >>> 6;
            if (num4 == 1)
            {
                long a = longArray1.m_ints[0];
                if (a == 1L)
                    return longArray2;
                long[] numArray = new long[length1];
                MultiplyWord( a, longArray2.m_ints, num5, numArray, 0 );
                return new LongArray( numArray, 0, length1 );
            }
            int num6 = num2 + 7 + 63 >>> 6;
            int[] numArray1 = new int[16];
            long[] numArray2 = new long[num6 << 4];
            int num7 = num6;
            numArray1[1] = num7;
            Array.Copy( longArray2.m_ints, 0, numArray2, num7, num5 );
            for (int index = 2; index < 16; ++index)
            {
                numArray1[index] = num7 += num6;
                if ((index & 1) == 0)
                    ShiftUp( numArray2, num7 >>> 1, numArray2, num7, num6, 1 );
                else
                    Add( numArray2, num6, numArray2, num7 - num6, numArray2, num7, num6 );
            }
            long[] numArray3 = new long[numArray2.Length];
            ShiftUp( numArray2, 0, numArray3, 0, numArray2.Length, 4 );
            long[] ints = longArray1.m_ints;
            long[] numArray4 = new long[length1 << 3];
            int num8 = 15;
            for (int index1 = 0; index1 < num4; ++index1)
            {
                long num9 = ints[index1];
                int xOff = index1;
                while (true)
                {
                    int index2 = (int)num9 & num8;
                    long num10 = num9 >>> 4;
                    int index3 = (int)num10 & num8;
                    AddBoth( numArray4, xOff, numArray2, numArray1[index2], numArray3, numArray1[index3], num6 );
                    num9 = num10 >>> 4;
                    if (num9 != 0L)
                        xOff += length1;
                    else
                        break;
                }
            }
            int length2 = numArray4.Length;
            while ((length2 -= length1) != 0)
                AddShiftedUp( numArray4, length2 - length1, numArray4, length2, length1, 8 );
            return new LongArray( numArray4, 0, length1 );
        }

        public void Reduce( int m, int[] ks )
        {
            long[] ints = this.m_ints;
            int length = ReduceInPlace( ints, 0, ints.Length, m, ks );
            if (length >= ints.Length)
                return;
            this.m_ints = new long[length];
            Array.Copy( ints, 0, m_ints, 0, length );
        }

        private static LongArray ReduceResult( long[] buf, int off, int len, int m, int[] ks )
        {
            int len1 = ReduceInPlace( buf, off, len, m, ks );
            return new LongArray( buf, off, len1 );
        }

        private static int ReduceInPlace( long[] buf, int off, int len, int m, int[] ks )
        {
            int num1 = (m + 63) >> 6;
            if (len < num1)
                return len;
            int BitLength = System.Math.Min( len << 6, (m << 1) - 1 );
            int num2;
            for (num2 = (len << 6) - BitLength; num2 >= 64; num2 -= 64)
                --len;
            int length = ks.Length;
            int k1 = ks[length - 1];
            int k2 = length > 1 ? ks[length - 2] : 0;
            int toBit = System.Math.Max( m, k1 + 64 );
            int num3 = (num2 + System.Math.Min( BitLength - toBit, m - k2 )) >> 6;
            if (num3 > 1)
            {
                int words = len - num3;
                ReduceVectorWise( buf, off, len, words, m, ks );
                while (len > words)
                    buf[off + --len] = 0L;
                BitLength = words << 6;
            }
            if (BitLength > toBit)
            {
                ReduceWordWise( buf, off, len, toBit, m, ks );
                BitLength = toBit;
            }
            if (BitLength > m)
                ReduceBitWise( buf, off, BitLength, m, ks );
            return num1;
        }

        private static void ReduceBitWise( long[] buf, int off, int BitLength, int m, int[] ks )
        {
            while (--BitLength >= m)
            {
                if (TestBit( buf, off, BitLength ))
                    ReduceBit( buf, off, BitLength, m, ks );
            }
        }

        private static void ReduceBit( long[] buf, int off, int bit, int m, int[] ks )
        {
            FlipBit( buf, off, bit );
            int n = bit - m;
            int length = ks.Length;
            while (--length >= 0)
                FlipBit( buf, off, ks[length] + n );
            FlipBit( buf, off, n );
        }

        private static void ReduceWordWise( long[] buf, int off, int len, int toBit, int m, int[] ks )
        {
            int num1 = toBit >>> 6;
            while (--len > num1)
            {
                long word = buf[off + len];
                if (word != 0L)
                {
                    buf[off + len] = 0L;
                    ReduceWord( buf, off, len << 6, word, m, ks );
                }
            }
            int num2 = toBit & 63;
            long word1 = buf[off + num1] >>> num2;
            if (word1 == 0L)
                return;
            buf[off + num1] ^= word1 << num2;
            ReduceWord( buf, off, toBit, word1, m, ks );
        }

        private static void ReduceWord( long[] buf, int off, int bit, long word, int m, int[] ks )
        {
            int bit1 = bit - m;
            int length = ks.Length;
            while (--length >= 0)
                FlipWord( buf, off, bit1 + ks[length], word );
            FlipWord( buf, off, bit1, word );
        }

        private static void ReduceVectorWise(
          long[] buf,
          int off,
          int len,
          int words,
          int m,
          int[] ks )
        {
            int bits = (words << 6) - m;
            int length = ks.Length;
            while (--length >= 0)
                FlipVector( buf, off, buf, off + words, len - words, bits + ks[length] );
            FlipVector( buf, off, buf, off + words, len - words, bits );
        }

        private static void FlipVector( long[] x, int xOff, long[] y, int yOff, int yLen, int bits )
        {
            xOff += bits >>> 6;
            bits &= 63;
            if (bits == 0)
            {
                Add( x, xOff, y, yOff, yLen );
            }
            else
            {
                long num = AddShiftedDown( x, xOff + 1, y, yOff, yLen, 64 - bits );
                x[xOff] ^= num;
            }
        }

        public LongArray ModSquare( int m, int[] ks )
        {
            int usedLength = this.GetUsedLength();
            if (usedLength == 0)
                return this;
            int length = usedLength << 1;
            long[] numArray1 = new long[length];
            int num1 = 0;
            while (num1 < length)
            {
                long x = this.m_ints[(int)(IntPtr)(uint)(num1 >>> 1)];
                long[] numArray2 = numArray1;
                int index1 = num1;
                int num2 = index1 + 1;
                long num3 = Interleave2_32to64( (int)x );
                numArray2[index1] = num3;
                long[] numArray3 = numArray1;
                int index2 = num2;
                num1 = index2 + 1;
                long num4 = Interleave2_32to64( (int)(x >>> 32) );
                numArray3[index2] = num4;
            }
            return new LongArray( numArray1, 0, ReduceInPlace( numArray1, 0, numArray1.Length, m, ks ) );
        }

        public LongArray ModSquareN( int n, int m, int[] ks )
        {
            int num = this.GetUsedLength();
            if (num == 0)
                return this;
            long[] numArray = new long[(m + 63) >> 6 << 1];
            Array.Copy( m_ints, 0, numArray, 0, num );
            while (--n >= 0)
            {
                SquareInPlace( numArray, num, m, ks );
                num = ReduceInPlace( numArray, 0, numArray.Length, m, ks );
            }
            return new LongArray( numArray, 0, num );
        }

        public LongArray Square( int m, int[] ks )
        {
            int usedLength = this.GetUsedLength();
            if (usedLength == 0)
                return this;
            int length = usedLength << 1;
            long[] ints = new long[length];
            int num1 = 0;
            while (num1 < length)
            {
                long x = this.m_ints[(int)(IntPtr)(uint)(num1 >>> 1)];
                long[] numArray1 = ints;
                int index1 = num1;
                int num2 = index1 + 1;
                long num3 = Interleave2_32to64( (int)x );
                numArray1[index1] = num3;
                long[] numArray2 = ints;
                int index2 = num2;
                num1 = index2 + 1;
                long num4 = Interleave2_32to64( (int)(x >>> 32) );
                numArray2[index2] = num4;
            }
            return new LongArray( ints, 0, ints.Length );
        }

        private static void SquareInPlace( long[] x, int xLen, int m, int[] ks )
        {
            int num1 = xLen << 1;
            while (--xLen >= 0)
            {
                long x1 = x[xLen];
                int num2;
                x[num2 = num1 - 1] = Interleave2_32to64( (int)(x1 >>> 32) );
                x[num1 = num2 - 1] = Interleave2_32to64( (int)x1 );
            }
        }

        private static void Interleave( long[] x, int xOff, long[] z, int zOff, int count, int width )
        {
            switch (width)
            {
                case 3:
                    Interleave3( x, xOff, z, zOff, count );
                    break;
                case 5:
                    Interleave5( x, xOff, z, zOff, count );
                    break;
                case 7:
                    Interleave7( x, xOff, z, zOff, count );
                    break;
                default:
                    Interleave2_n( x, xOff, z, zOff, count, BitLengths[width] - 1 );
                    break;
            }
        }

        private static void Interleave3( long[] x, int xOff, long[] z, int zOff, int count )
        {
            for (int index = 0; index < count; ++index)
                z[zOff + index] = Interleave3( x[xOff + index] );
        }

        private static long Interleave3( long x ) => (x & long.MinValue) | Interleave3_21to63( (int)x & 2097151 ) | (Interleave3_21to63( (int)(x >>> 21) & 2097151 ) << 1) | (Interleave3_21to63( (int)(x >>> 42) & 2097151 ) << 2);

        private static long Interleave3_21to63( int x )
        {
            int num1 = INTERLEAVE3_TABLE[x & sbyte.MaxValue];
            int num2 = INTERLEAVE3_TABLE[(int)(IntPtr)(uint)(x >>> 7 & sbyte.MaxValue)];
            return ((INTERLEAVE3_TABLE[(int)(IntPtr)(uint)(x >>> 14)] & uint.MaxValue) << 42) | ((num2 & uint.MaxValue) << 21) | (num1 & uint.MaxValue);
        }

        private static void Interleave5( long[] x, int xOff, long[] z, int zOff, int count )
        {
            for (int index = 0; index < count; ++index)
                z[zOff + index] = Interleave5( x[xOff + index] );
        }

        private static long Interleave5( long x ) => Interleave3_13to65( (int)x & 8191 ) | (Interleave3_13to65( (int)(x >>> 13) & 8191 ) << 1) | (Interleave3_13to65( (int)(x >>> 26) & 8191 ) << 2) | (Interleave3_13to65( (int)(x >>> 39) & 8191 ) << 3) | (Interleave3_13to65( (int)(x >>> 52) & 8191 ) << 4);

        private static long Interleave3_13to65( int x )
        {
            int num = INTERLEAVE5_TABLE[x & sbyte.MaxValue];
            return ((INTERLEAVE5_TABLE[(int)(IntPtr)(uint)(x >>> 7)] & uint.MaxValue) << 35) | (num & uint.MaxValue);
        }

        private static void Interleave7( long[] x, int xOff, long[] z, int zOff, int count )
        {
            for (int index = 0; index < count; ++index)
                z[zOff + index] = Interleave7( x[xOff + index] );
        }

        private static long Interleave7( long x ) => (x & long.MinValue) | INTERLEAVE7_TABLE[(int)x & 511] | (INTERLEAVE7_TABLE[(int)(x >>> 9) & 511] << 1) | (INTERLEAVE7_TABLE[(int)(x >>> 18) & 511] << 2) | (INTERLEAVE7_TABLE[(int)(x >>> 27) & 511] << 3) | (INTERLEAVE7_TABLE[(int)(x >>> 36) & 511] << 4) | (INTERLEAVE7_TABLE[(int)(x >>> 45) & 511] << 5) | (INTERLEAVE7_TABLE[(int)(x >>> 54) & 511] << 6);

        private static void Interleave2_n(
          long[] x,
          int xOff,
          long[] z,
          int zOff,
          int count,
          int rounds )
        {
            for (int index = 0; index < count; ++index)
                z[zOff + index] = Interleave2_n( x[xOff + index], rounds );
        }

        private static long Interleave2_n( long x, int rounds )
        {
            while (rounds > 1)
            {
                rounds -= 2;
                x = Interleave4_16to64( (int)x & ushort.MaxValue ) | (Interleave4_16to64( (int)(x >>> 16) & ushort.MaxValue ) << 1) | (Interleave4_16to64( (int)(x >>> 32) & ushort.MaxValue ) << 2) | (Interleave4_16to64( (int)(x >>> 48) & ushort.MaxValue ) << 3);
            }
            if (rounds > 0)
                x = Interleave2_32to64( (int)x ) | (Interleave2_32to64( (int)(x >>> 32) ) << 1);
            return x;
        }

        private static long Interleave4_16to64( int x )
        {
            int num = INTERLEAVE4_TABLE[x & byte.MaxValue];
            return ((INTERLEAVE4_TABLE[(int)(IntPtr)(uint)(x >>> 8)] & uint.MaxValue) << 32) | (num & uint.MaxValue);
        }

        private static long Interleave2_32to64( int x )
        {
            int num = INTERLEAVE2_TABLE[x & byte.MaxValue] | (INTERLEAVE2_TABLE[(int)(IntPtr)(uint)(x >>> 8 & byte.MaxValue)] << 16);
            return (((INTERLEAVE2_TABLE[(int)(IntPtr)(uint)(x >>> 16 & byte.MaxValue)] | (INTERLEAVE2_TABLE[(int)(IntPtr)(uint)(x >>> 24)] << 16)) & uint.MaxValue) << 32) | (num & uint.MaxValue);
        }

        public LongArray ModInverse( int m, int[] ks )
        {
            int num1 = this.Degree();
            switch (num1)
            {
                case 0:
                    throw new InvalidOperationException();
                case 1:
                    return this;
                default:
                    LongArray longArray1 = this.Copy();
                    int intLen = (m + 63) >> 6;
                    LongArray longArray2 = new( intLen );
                    ReduceBit( longArray2.m_ints, 0, m, m, ks );
                    LongArray longArray3 = new( intLen );
                    longArray3.m_ints[0] = 1L;
                    LongArray longArray4 = new( intLen );
                    int[] numArray1 = new int[2] { num1, m + 1 };
                    LongArray[] longArrayArray1 = new LongArray[2]
                    {
            longArray1,
            longArray2
                    };
                    int[] numArray2 = new int[2] { 1, 0 };
                    LongArray[] longArrayArray2 = new LongArray[2]
                    {
            longArray3,
            longArray4
                    };
                    int index = 1;
                    int limit1 = numArray1[index];
                    int limit2 = numArray2[index];
                    int bits = limit1 - numArray1[1 - index];
                    while (true)
                    {
                        if (bits < 0)
                        {
                            bits = -bits;
                            numArray1[index] = limit1;
                            numArray2[index] = limit2;
                            index = 1 - index;
                            limit1 = numArray1[index];
                            limit2 = numArray2[index];
                        }
                        longArrayArray1[index].AddShiftedByBitsSafe( longArrayArray1[1 - index], numArray1[1 - index], bits );
                        int num2 = longArrayArray1[index].DegreeFrom( limit1 );
                        if (num2 != 0)
                        {
                            int otherDegree = numArray2[1 - index];
                            longArrayArray2[index].AddShiftedByBitsSafe( longArrayArray2[1 - index], otherDegree, bits );
                            int num3 = otherDegree + bits;
                            if (num3 > limit2)
                                limit2 = num3;
                            else if (num3 == limit2)
                                limit2 = longArrayArray2[index].DegreeFrom( limit2 );
                            bits += num2 - limit1;
                            limit1 = num2;
                        }
                        else
                            break;
                    }
                    return longArrayArray2[1 - index];
            }
        }

        public override bool Equals( object obj ) => this.Equals( obj as LongArray );

        public virtual bool Equals( LongArray other )
        {
            if (this == other)
                return true;
            if (other == null)
                return false;
            int usedLength = this.GetUsedLength();
            if (other.GetUsedLength() != usedLength)
                return false;
            for (int index = 0; index < usedLength; ++index)
            {
                if (this.m_ints[index] != other.m_ints[index])
                    return false;
            }
            return true;
        }

        public override int GetHashCode()
        {
            int usedLength = this.GetUsedLength();
            int hashCode = 1;
            for (int index = 0; index < usedLength; ++index)
            {
                long num = this.m_ints[index];
                hashCode = (((hashCode * 31) ^ (int)num) * 31) ^ (int)(num >>> 32);
            }
            return hashCode;
        }

        public LongArray Copy() => new( Arrays.Clone( this.m_ints ) );

        public override string ToString()
        {
            int usedLength = this.GetUsedLength();
            if (usedLength == 0)
                return "0";
            int index;
            StringBuilder stringBuilder = new( Convert.ToString( this.m_ints[index = usedLength - 1], 2 ) );
            while (--index >= 0)
            {
                string str = Convert.ToString( this.m_ints[index], 2 );
                int length = str.Length;
                if (length < 64)
                    stringBuilder.Append( "0000000000000000000000000000000000000000000000000000000000000000".Substring( length ) );
                stringBuilder.Append( str );
            }
            return stringBuilder.ToString();
        }
    }
}
